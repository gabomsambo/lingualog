from typing import Optional, List, Dict, Any, Union
from pydantic import BaseModel, Field, EmailStr, HttpUrl, AliasChoices
import uuid
from datetime import datetime

# --- Authentication Models ---
class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None

class User(BaseModel):
    id: uuid.UUID
    email: EmailStr
    full_name: Optional[str] = None
    is_active: bool = True
    is_superuser: bool = False
    created_at: datetime
    updated_at: datetime

class UserInDB(User):
    hashed_password: str

class UserCreate(BaseModel):
    email: EmailStr
    password: str
    full_name: Optional[str] = None

class UserUpdate(BaseModel):
    email: Optional[EmailStr] = None
    full_name: Optional[str] = None
    password: Optional[str] = None # To update password
    is_active: Optional[bool] = None
    is_superuser: Optional[bool] = None

class LoginRequest(BaseModel):
    username: EmailStr # Assuming email is used as username
    password: str


# --- Journal Entry Models ---
class JournalEntryBase(BaseModel):
    language: str = Field(..., description="Language of the journal entry (e.g., 'en', 'es', 'ja').")
    title: Optional[str] = Field(None, max_length=255, description="Optional title for the entry.")
    content: str = Field(..., validation_alias=AliasChoices('content', 'original_text'), description="The main text content of the journal entry.")
    tags: Optional[List[str]] = Field(None, description="Optional tags for categorizing the entry.")

class JournalEntryCreate(JournalEntryBase):
    pass

class JournalEntryUpdate(JournalEntryBase):
    language: Optional[str] = None
    content: Optional[str] = None
    # Allow partial updates for all fields

class AiFeedback(BaseModel):
    # Use Union types and aliases to handle different data formats
    corrected_content: Optional[Union[str, Dict]] = Field(None, alias="corrected", validation_alias=AliasChoices("corrected", "corrected_content"))
    fluent_rewrite: Optional[Union[str, Dict]] = Field(None, alias="rewrite", validation_alias=AliasChoices("rewrite", "fluent_rewrite"))
    overall_score: Optional[Union[float, int, str]] = Field(None, alias="score", validation_alias=AliasChoices("score", "overall_score"))
    tone_analysis: Optional[Union[str, Dict[str, float]]] = Field(None, alias="tone", validation_alias=AliasChoices("tone", "tone_analysis"))
    style_analysis: Optional[Dict[str, float]] = Field(None) # Assuming this structure is fairly stable
    grammar_suggestions: Optional[Union[List[Dict[str, Any]], List[str]]] = Field(None)
    vocabulary_suggestions: Optional[List[Dict[str, Any]]] = Field(None)
    new_words_used: Optional[Union[List[str], List[Dict[str, Any]]]] = Field(None, alias="new_words", validation_alias=AliasChoices("new_words", "new_words_used"))
    explanation_of_changes: Optional[str] = Field(None, alias="explanation", validation_alias=AliasChoices("explanation", "explanation_of_changes"))

    # Add any fields that appear in logs but aren't in the model (or that you know might be present)
    translation: Optional[str] = Field(None)
    rubric: Optional[Dict[str, Any]] = Field(None) # Example of a potentially complex field

    model_config = {
        "populate_by_name": True, # Allows use of aliases for population
        "from_attributes": True,  # Replaces orm_mode=True for Pydantic V2
        "extra": "ignore"         # Ignore unknown fields instead of failing
    }

class JournalEntry(JournalEntryBase):
    id: uuid.UUID
    user_id: uuid.UUID
    created_at: datetime
    updated_at: datetime
    ai_feedback: Optional[AiFeedback] = None # Now directly part of the entry

    model_config = {
        "from_attributes": True # Pydantic V2 way for orm_mode
    }

class JournalEntryWithScore(JournalEntry): # For specific queries needing score prominently
    average_score: Optional[float] = None


# --- Vocabulary Models ---

class WordAiCacheBase(BaseModel):
    language: str = Field(..., description="Language of the word (e.g., 'en', 'es', 'ja').")
    ai_example_sentences: Optional[List[str]] = Field(None, description="Example sentences generated by AI.")
    ai_definitions: Optional[List[Dict[str, str]]] = Field(None, description="Definitions generated by AI (e.g., [{'part_of_speech': 'noun', 'definition': '...'}]).")
    ai_synonyms: Optional[List[str]] = Field(None, description="Synonyms generated by AI.")
    ai_antonyms: Optional[List[str]] = Field(None, description="Antonyms generated by AI.")
    ai_related_phrases: Optional[List[str]] = Field(None, description="Related phrases or idioms generated by AI.")
    ai_conjugation_info: Optional[Dict[str, Any]] = Field(None, description="Conjugation information if applicable (structure depends on language).")
    ai_cultural_note: Optional[str] = Field(None, description="Cultural context or usage notes from AI.")
    ai_pronunciation_guide: Optional[str] = Field(None, description="Text-based pronunciation guide from AI (e.g., IPA or romaji).")
    ai_alternative_forms: Optional[List[str]] = Field(None, description="Alternative forms or spellings from AI.")
    ai_common_mistakes: Optional[List[Dict[str, str]]] = Field(None, description="Common mistakes learners make with this word, from AI.")
    # New fields for comprehensive vocabulary enrichment
    emotion_tone: Optional[str] = Field(None, description="Emotional tone or feeling associated with this word.")
    mnemonic: Optional[str] = Field(None, description="Memory aid, metaphor, or mnemonic device for remembering this word.")
    emoji: Optional[str] = Field(None, description="Emoji that represents the emotion or concept of this word.")
    source_model: Optional[str] = Field(None, description="AI model used to generate this cache entry.")

class WordAiCacheCreate(WordAiCacheBase):
    word_vocabulary_id: uuid.UUID # Foreign key

class WordAiCacheDB(WordAiCacheBase):
    id: uuid.UUID
    word_vocabulary_id: uuid.UUID # Foreign key
    created_at: datetime
    updated_at: datetime
    last_accessed_at: datetime

    model_config = {
        "from_attributes": True
    }

class EnrichedWordDetailsResponse(WordAiCacheBase):
    id: uuid.UUID = Field(..., description="Unique identifier for the AI cache entry.")
    word_vocabulary_id: uuid.UUID = Field(..., description="Foreign key to the user_vocabulary_item.id this cache entry pertains to.")


# <<< BEGIN ON-DEMAND AI MODELS >>>

class MoreExamplesRequest(BaseModel):
    word: str = Field(..., description="The word to generate more examples for.")
    language: str = Field(..., description="The language of the word (e.g., 'en', 'es', 'ja').")
    existing_examples: Optional[List[str]] = Field(None, description="Existing example sentences to avoid repetition and provide context.")
    target_audience_level: Optional[str] = Field("intermediate", description="Target audience proficiency level (e.g., beginner, intermediate, advanced).")

class MoreExamplesResponse(BaseModel):
    new_example_sentences: List[str] = Field(..., description="Newly generated example sentences.")

class ELI5Request(BaseModel):
    term: str = Field(..., description="The term or concept to explain like I'm five.")
    language: str = Field(..., description="The language for the explanation (e.g., 'en', 'es', 'ja').")
    # context: Optional[str] = Field(None, description="Optional context about the term or its usage.") # Consider if needed

class ELI5Response(BaseModel):
    explanation: str = Field(..., description="The ELI5 explanation.")

class MiniQuizQuestion(BaseModel):
    question_text: str = Field(..., description="The text of the quiz question.")
    options: List[str] = Field(..., description="A list of possible answers.")
    correct_answer_index: int = Field(..., description="The 0-based index of the correct answer in the options list.")
    explanation: Optional[str] = Field(None, description="An optional explanation for why the answer is correct.")

class MiniQuizRequest(BaseModel):
    word: str = Field(..., description="The word or concept the quiz should be about.")
    language: str = Field(..., description="The language for the quiz (e.g., 'en', 'es', 'ja').")
    difficulty_level: Optional[str] = Field("medium", description="Difficulty level of the quiz (e.g., easy, medium, hard).")
    num_questions: Optional[int] = Field(3, description="Number of questions for the mini-quiz.")

class MiniQuizResponse(BaseModel):
    quiz_title: str = Field(..., description="A title for the mini-quiz.")
    questions: List[MiniQuizQuestion] = Field(..., description="A list of quiz questions.")

# <<< END ON-DEMAND AI MODELS >>>


class UserVocabularyItemBase(BaseModel):
    user_id: uuid.UUID
    term: str = Field(..., max_length=255)
    language: str = Field(..., max_length=10, description="Language code, e.g., 'en', 'es', 'ja'")
    part_of_speech: Optional[str] = Field(None, max_length=50)
    definition: Optional[str] = Field(None)
    reading: Optional[str] = Field(None)  # Database field name
    example_sentence: Optional[str] = Field(None)  # Database field name
    status: Optional[str] = Field(None)  # Database field name
    entry_id: Optional[uuid.UUID] = Field(None)  # Database field name
    learning_status: Optional[str] = Field("new", description="e.g., new, learning, known, mastered")
    familiarity_score: Optional[int] = Field(0, ge=0, le=10, description="User's self-assessed familiarity (0-10)")
    last_reviewed_at: Optional[datetime] = None
    next_review_due_at: Optional[datetime] = None
    tags: Optional[List[str]] = Field(None)
    notes_user: Optional[str] = Field(None, description="User's personal notes about the word.")
    
    # AI Enrichment fields (now stored directly in user_vocabulary)
    ai_example_sentences: Optional[List[str]] = Field(None)
    ai_definitions: Optional[List[str]] = Field(None)
    ai_synonyms: Optional[List[str]] = Field(None)
    ai_antonyms: Optional[List[str]] = Field(None)
    ai_related_phrases: Optional[List[str]] = Field(None)
    ai_conjugation_info: Optional[Dict[str, Any]] = Field(None)
    ai_cultural_note: Optional[str] = Field(None)
    ai_pronunciation_guide: Optional[str] = Field(None)
    ai_alternative_forms: Optional[List[str]] = Field(None)
    ai_common_mistakes: Optional[List[str]] = Field(None)
    emotion_tone: Optional[str] = Field(None)
    mnemonic: Optional[str] = Field(None)
    emoji: Optional[str] = Field(None)
    source_model: Optional[str] = Field(None)

class UserVocabularyItemCreate(UserVocabularyItemBase):
    pass

class UserVocabularyItemUpdate(BaseModel):
    word: Optional[str] = Field(None, max_length=255)
    language: Optional[str] = Field(None, max_length=10)
    part_of_speech: Optional[str] = Field(None, max_length=50)
    definition: Optional[str] = None
    example_sentence_user: Optional[str] = None
    translation_user: Optional[str] = None
    learning_status: Optional[str] = None
    familiarity_score: Optional[int] = Field(None, ge=0, le=10)
    last_reviewed_at: Optional[datetime] = None
    next_review_due_at: Optional[datetime] = None
    tags: Optional[List[str]] = None
    notes_user: Optional[str] = None
    pronunciation_user: Optional[str] = None
    # user_id and source_entry_id are generally not updatable this way

class UserVocabularyItem(UserVocabularyItemBase):
    id: uuid.UUID
    created_at: datetime
    updated_at: datetime
    ai_enrichment: Optional[EnrichedWordDetailsResponse] = None # To hold enriched data when sending to client

    model_config = {
        "from_attributes": True
    }

# For responses that might include the full cache object or just its ID
class UserVocabularyItemResponse(UserVocabularyItem):
    # If we want to embed the full cache details directly, it's already in ai_enrichment.
    # If we only wanted to send word_ai_cache_id, we'd add it here.
    # For now, ai_enrichment serves to hold the details from EnrichedWordDetailsResponse.
    pass


# --- Translation Models ---
class TranslationRequest(BaseModel):
    text: str = Field(..., description="Text to be translated.")
    target_lang: str = Field(..., description="Target language code (e.g., 'en', 'es').")
    source_lang: Optional[str] = Field(None, description="Optional source language code. If not provided, auto-detection may be attempted.")

class TranslationOutput(BaseModel):
    translated_text: str = Field(..., description="The translated text.")
    detected_source_lang: Optional[str] = Field(None, description="The detected source language code (e.g., 'en', 'es').")


# --- System / Config Models ---
class AppEnvironment(BaseModel):
    ENV_NAME: str
    SENTRY_DSN: Optional[HttpUrl] = None
    # Add other critical environment variables here

    # Supabase
    SUPABASE_URL: HttpUrl
    SUPABASE_KEY: str
    SUPABASE_SERVICE_ROLE_KEY: str # For admin operations

    # JWT
    JWT_SECRET_KEY: str
    JWT_ALGORITHM: str = "HS256"
    JWT_ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7 # 7 days


    # AI Provider Config
    AI_PROVIDER: str = "gemini" # gemini, openai, mistral, claude etc.
    GEMINI_API_KEY: Optional[str] = None
    OPENAI_API_KEY: Optional[str] = None
    # ... other provider keys

    model_config = {
        "extra": "ignore" # Allow other env vars not explicitly defined
    }

class MessageResponse(BaseModel):
    message: str 